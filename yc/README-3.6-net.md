# Домашнее задание к занятию "3.6. Компьютерные сети, лекция 1"

1. Необязательное задание:
можно посмотреть целый фильм в консоли `telnet towel.blinkenlights.nl` :)

> ;-)))



2. Узнайте о том, сколько действительно независимых (не пересекающихся) каналов есть в разделяемой среде WiFi при работе на 2.4 ГГц. Стандарты с полосой 5 ГГц более актуальны, но регламенты на 5 ГГц существенно различаются в разных странах, а так же не раз обновлялись. В качестве дополнительного вопроса вне зачета, попробуйте найти актуальный ответ и на этот вопрос.


> Очень хорошая статья - https://interface31.ru/tech_it/2019/09/normativnoe-regulirovanie-wi-fi-v-rf.html, из которой становится ясно, что кроме технических рамок, существуют и ограничения регулатора и по по диапазонам с номерами каналов, и по мощности передатчиков. Для 2,4 ГГц - имеем 3 непересекающихся (условно) канала. Даннное условно, так как используется зачастую 40 МГц (вместо 20 МГц) для ширины канала, что может привести к отсутствию свободных каналов (ни одного из 13-ти в диапазоне 2401-2483 МГц). Что же касается разработанного диапазона 5 Ггц который должен был решить данную проблему, то тут тоже не все просто, и, хотя диапазон содержит 	 



3. Адрес канального уровня – MAC адрес – это 6 байт, первые 3 из которых называются OUI – Organizationally Unique Identifier или уникальный идентификатор организации. Какому производителю принадлежит MAC `38:f9:d3:55:55:79`?


> https://hwaddress.com/oui-iab/38-F9-D3/ - даст понять, что это Apple, inc.



4. Каким будет payload TCP сегмента, если Ethernet MTU задан в 9001 байт, размер заголовков IPv4 – 20 байт, а TCP – 32 байта?

> Будет равным 8049 бафйт (9001 - 20 - 32 = 8049), если иное не установлено с пом. TCPMSS:

```bash

iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 8000 


```

5. Может ли во флагах TCP одновременно быть установлены флаги SYN и FIN при штатном режиме работы сети? Почему да или нет?


> TCP хэндшейк между стороной 1 и 2 устанавливается так: syn (1) - syn,ack (2)  - ack (1), а вот завершение соединения TCP так: fin (1) - ack (2) далее fin (2) - ack (1). Но, возможно трехсторонне квитирование: fin (1) - fin,ack (2) - ack (1), если у 2 более не данных для передачи в момент получения fin от 1.    



6. `ss -ula sport = :53` на хосте имеет следующий вывод:

```bash
State           Recv-Q          Send-Q                   Local Address:Port                     Peer Address:Port          Process
UNCONN          0               0                        127.0.0.53%lo:domain                        0.0.0.0:*
```

Почему в `State` присутствует только `UNCONN`, и может ли там присутствовать, например, `TIME-WAIT`?

> Потому-что UDP у него отсутствует хендшейк (фаза установки соединения) как у TCP, по этой же причине отсутствует TIME-WAIT.


7. Обладая знаниями о том, как штатным образом завершается соединение (FIN от инициатора, FIN-ACK от ответчика, ACK от инициатора), опишите в каких состояниях будет находиться TCP соединение в каждый момент времени на клиенте и на сервере при завершении. Схема переходов состояния соединения вам в этом поможет.


> Трехсторонне квитирование: fin (1) - fin,ack (2) - ack (1), если у 2 более не данных для передачи в момент получения fin от 1.    


8. TCP порт – 16 битное число. Предположим, 2 находящихся в одной сети хоста устанавливают между собой соединения. Каким будет теоретическое максимальное число соединений, ограниченное только лишь параметрами L4, которое параллельно может установить клиент с одного IP адреса к серверу с одним IP адресом? Сколько соединений сможет обслужить сервер от одного клиента? А если клиентов больше одного?

> Предположим веб-сервер обслуживает порт 80 (один из привелигерованных 1-1024 портов), а клиент(ы) любой непревилегированный или эфимерный (1025-65535) - для установки TCP соединения. Так как веб сервер для различия соединений друг от друга использует запись 4 переменную называемую Кортеж - ip клиента, порт клиента, ip сервера, порт сервера - то теоретически соединений на порт сервера может быть очень большое. Другой дело, что одно соединение это ~ 1 КБ ОЗУ и 65 миллионов соединений займет 65 ГБ ОЗУ, что видимо будет тяжело для сервера. Есть ограничения в реестре ОС, которая дополнительно, кроме максимального количества, проверяет неотвечающие соединения. Но с одного клиента получится сделать 65 тыс. исходящих соединений. 


9. Может ли сложиться ситуация, при которой большое число соединений TCP на хосте находятся в состоянии  `TIME-WAIT`? Если да, то является ли она хорошей или плохой? Подкрепите свой ответ пояснением той или иной оценки.

> Да, может. И если это случилось, то вероятнее всего это атака назваемая SYN-flood, целью которой является вывод из строя сервера посылкой большого колличества SYNфаз TCP -хендшейков, вероятнее всего одновременно с разных хостов. TCP syn без последующих фаз и собственно рабочих данных для отправки, только для целей необходимости обработки сервером (траты ОЗУ и времени). Так же уязвимость регулируется настройками веб-сервера и файервола. 


10. Чем особенно плоха фрагментация UDP относительно фрагментации TCP?



> Несмотря на то, что процесс фрагментации IP выглядит довольно прозрачным, существует одна особенность, которая делает его не всегда желательным: если один фрагмент потерялся, датаграмма должна быть целиком повторно передана. Это объясняется тем, что IP не имеет тайм-аутов и не осуществляет повторной передачи - за это несут ответственность верхние уровни. (TCP осуществляет тайм-аут и повторную передачу, UDP - нет. 
> Другими словами, если потеряется фрагммент UDP - он не будет перепередан, что отразтся на качестве видео, звука, потери других данных.
> Некоторые UDP приложения осуществляют тайм-аут и повторную передачу самостоятельно.) Когда потерялся фрагмент из TCP сегмента, TCP отработает тайм-аут и повторно передаст TCP сегмент целиком (IP датаграмма). Не существует способа повторно передать только один фрагмент датаграммы. И действительно, если фрагментация была осуществлена промежуточным маршрутизатором, а не отправляющей системой, отправляющая система не сможет знать как датаграмма была фрагментирована в процессе передачи. Именно по этой причине (всего одной) фрагментации стараются избежать.



11. Если бы вы строили систему удаленного сбора логов, то есть систему, в которой несколько хостов отправяют на центральный узел генерируемые приложениями логи (предположим, что логи – текстовая информация), какой протокол транспортного уровня вы выбрали бы и почему? Проверьте ваше предположение самостоятельно, узнав о стандартном протоколе syslog.


> Конечно, если среда ненадежная, то TCP, как гарантирующий доставку данных. Но зачастую используется UDP порт 514, а если TCP, то 601, 1468. UDP, так как обыно RSyslog сервер находится в той же сети, что и сервер(ы) пишущий(е) данные логи, и величины отправляемых данных, которые сами могут быть источником проблем при чрезмерности логгирования. 


12. Сколько портов TCP находится в состоянии прослушивания на вашей виртуальной машине с Ubuntu, и каким процессам они принадлежат?


```bash
root@dev1-10:~# ss -lt | wc -l
36
```

> Из них, 31 c распознанной командной строкой процесса:

```bash
root@dev1-10:~# ss -ltp | awk '{print $6}' | grep -P '(users:)'
users:(("netdata",pid=674858,fd=35))
users:(("netdata",pid=673443,fd=35))
users:(("netdata",pid=674858,fd=4))
users:(("netdata",pid=673443,fd=4))
users:(("mysqld",pid=731,fd=27))
users:(("memcached",pid=431842,fd=26))
users:(("rpc.mountd",pid=700499,fd=13))
users:(("rpc.mountd",pid=700499,fd=17))
users:(("rpcbind",pid=698650,fd=4),("systemd",pid=1,fd=370))
users:(("apache2",pid=1413611,fd=3),("apache2",pid=1413610,fd=3),("apache2",pid=1413609,fd=3),("apache2",pid=1413608,fd=3),("apache2",pid=1413607,fd=3),("apache2",pid=1413606,fd=3),("apache2",pid=727422,fd=3))
users:(("rpc.mountd",pid=700499,fd=9))
users:(("apache2",pid=1413611,fd=7),("apache2",pid=1413610,fd=7),("apache2",pid=1413609,fd=7),("apache2",pid=1413608,fd=7),("apache2",pid=1413607,fd=7),("apache2",pid=1413606,fd=7),("apache2",pid=727422,fd=7))
users:(("sshd",pid=613,fd=3))
users:(("apache2",pid=1413611,fd=6),("apache2",pid=1413610,fd=6),("apache2",pid=1413609,fd=6),("apache2",pid=1413608,fd=6),("apache2",pid=1413607,fd=6),("apache2",pid=1413606,fd=6),("apache2",pid=727422,fd=6))
users:(("exim4",pid=1335,fd=4))
users:(("apache2",pid=1413611,fd=5),("apache2",pid=1413610,fd=5),("apache2",pid=1413609,fd=5),("apache2",pid=1413608,fd=5),("apache2",pid=1413607,fd=5),("apache2",pid=1413606,fd=5),("apache2",pid=727422,fd=5))
users:(("apache2",pid=1413611,fd=4),("apache2",pid=1413610,fd=4),("apache2",pid=1413609,fd=4),("apache2",pid=1413608,fd=4),("apache2",pid=1413607,fd=4),("apache2",pid=1413606,fd=4),("apache2",pid=727422,fd=4))
users:(("xrdp",pid=775,fd=11))
users:(("java",pid=51563,fd=13))
users:(("rpc.mountd",pid=700499,fd=11))
users:(("java",pid=623694,fd=40))
users:(("prometheus",pid=1354395,fd=8))
users:(("rpc.mountd",pid=700499,fd=19))
users:(("node_exporter",pid=727423,fd=3))
users:(("java",pid=51563,fd=54))
users:(("rpcbind",pid=698650,fd=6),("systemd",pid=1,fd=372))
users:(("java",pid=623694,fd=41))
users:(("xrdp-sesman",pid=617,fd=7))
users:(("squid",pid=878,fd=12))
users:(("exim4",pid=1335,fd=5))
users:(("rpc.mountd",pid=700499,fd=15))
root@dev1-10:~# 
```


> И остальные 5:



```bash
root@dev1-10:~# ss -ltp | awk '{print $4,$6}' | grep -vP '(users:)'
Local Peer
0.0.0.0:nfs 
0.0.0.0:33455 
[::]:nfs 
[::]:35303 

root@dev1-10:~# ss -ltp | awk '{print $4,$6}' | grep -vP '(users:)' | wc -l
5
root@dev1-10:~# ss -ltp | awk '{print $4,$6}' | grep -P '(users:)' | wc -l
31
root@dev1-10:~# 
```





13. Какой ключ нужно добавить в `tcpdump`, чтобы он начал выводить не только заголовки, но и содержимое фреймов в текстовом виде? А в текстовом и шестнадцатиричном?



> Без заголоков в ASCII, для полностью полученных пакетов -s 0 

```bash
root@dev1-10:~# tcpdump -As 0 proto TCP and port 80
```

> Без заголовков и в HEX и в ASCII рядом друг с другом. -XX даст дополнительно заголовки.

```bash
root@dev1-10:~# tcpdump -Xs 0 proto TCP and port 80
```

> С заголовками, в HEX, -x даст без заголовков.

```bash
root@dev1-10:~# tcpdump -xxs 0 proto TCP and port 80
```





14. Попробуйте собрать дамп трафика с помощью `tcpdump` на основном интерфейсе вашей виртуальной машины и посмотреть его через tshark или Wireshark (можно ограничить число пакетов `-c 100`). Встретились ли вам какие-то установленные флаги Internet Protocol (не флаги TCP, а флаги IP)? Узнайте, какие флаги бывают. Как на самом деле называется стандарт Ethernet, фреймы которого попали в ваш дамп? Можно ли где-то в дампе увидеть OUI?


> Попробовал собрать:


```bash
tcpdump -XX -i ens18 -c 100 -e | tee ./dump.pcap
```

> Чтобы собрать флаги ip надо добавить -v:

```bash
root@dev1-10:/home/demi/netol_do/devops-netology# tcpdump -XXv -i ens18 -c 100 -e | tee ./dump.pcap 
```

> У ip нашел такие флаги (из всех прив. ниже):


> Т.к. под поле флаги выделено три бита, этих три бита используются для контроля над фрагментацией пакетов. Немного отвлечемся непосредственно от флагов и заметим, что нумерация бит в поле начинается с нуля, крайний левый бит старший, а крайний правый – младший. Тогда у нас в поле Флаги получается следующая картина:

* нулевой бит зарезервирован и должен быть всегда равен нулю;
* если значение первого бита ноль, то допускается фрагментация пакетов, если единица (бит DF или Do not Fragment), то устройства компьютерной сети не будут выполнять фрагментацию;
* второй бит служит для того, чтобы конечные узлы понимали, где начинается последовательность фрагментированных пакетов, а где она заканчивается, если значение этого бита равно единице (MF More Fragments), то узел понимает, что этот пакет не последний и нужно ждать еще пакеты, чтобы собрать изначально разделенный пакет.



```bash

root@dev1-10:/home/demi/netol_do/devops-netology# tcpdump -XXv -i ens18 -c 100 -e | grep -P "(flags)" | awk '{print $22, $23, $24, $25}'
tcpdump: listening on ens18, link-type EN10MB (Ethernet), snapshot length 262144 bytes
flags [DF], proto TCP
flags [DF], proto TCP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
100 packets captured
169 packets received by filter
0 packets dropped by kernel
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
flags [none], proto UDP
flags [DF], proto UDP
root@dev1-10:/home/demi/netol_do/devops-netology# 


```



> Название «Ethernet» (буквально «эфирная сеть» или «среда сети») отражает первоначальный принцип работы этой технологии: всё, передаваемое одним узлом, одновременно принимается всеми остальными (то есть имеется некое сходство с радиовещанием). В настоящее время практически всегда подключение происходит через коммутаторы (switch), так что кадры, отправляемые одним узлом, доходят лишь до адресата (исключение составляют передачи на широковещательный адрес) — это повышает скорость работы и безопасность сети.









> Нашел OUI:




root@dev1-10:/home/demi/netol_do/devops-netology# tcpdump -XXv -i ens18 -c 100 -e | grep -P "(oui)" | awk '{print $5,$6,$7}'
tcpdump: listening on ens18, link-type EN10MB (Ethernet), snapshot length 262144 bytes


...
161 packets received by filter
0 packets dropped by kernel
root@dev1-10:/home/demi/netol_do/devops-netology# 







 
 ---

## Как сдавать задания

Обязательными к выполнению являются задачи без указания звездочки. Их выполнение необходимо для получения зачета и диплома о профессиональной переподготовке.

Задачи со звездочкой (*) являются дополнительными задачами и/или задачами повышенной сложности. Они не являются обязательными к выполнению, но помогут вам глубже понять тему.

Домашнее задание выполните в файле readme.md в github репозитории. В личном кабинете отправьте на проверку ссылку на .md-файл в вашем репозитории.

Также вы можете выполнить задание в [Google Docs](https://docs.google.com/document/u/0/?tgif=d) и отправить в личном кабинете на проверку ссылку на ваш документ.
Название файла Google Docs должно содержать номер лекции и фамилию студента. Пример названия: "1.1. Введение в DevOps — Сусанна Алиева".

Если необходимо прикрепить дополнительные ссылки, просто добавьте их в свой Google Docs.

Перед тем как выслать ссылку, убедитесь, что ее содержимое не является приватным (открыто на комментирование всем, у кого есть ссылка), иначе преподаватель не сможет проверить работу. Чтобы это проверить, откройте ссылку в браузере в режиме инкогнито.

[Как предоставить доступ к файлам и папкам на Google Диске](https://support.google.com/docs/answer/2494822?hl=ru&co=GENIE.Platform%3DDesktop)

[Как запустить chrome в режиме инкогнито ](https://support.google.com/chrome/answer/95464?co=GENIE.Platform%3DDesktop&hl=ru)

[Как запустить  Safari в режиме инкогнито ](https://support.apple.com/ru-ru/guide/safari/ibrw1069/mac)

Любые вопросы по решению задач задавайте в чате Slack.

---
